1. Вывести информацию об используемом дистрибутиве

Способ первый - читаем через cat из файла os-release:
```
cat /etc/*rel*
```

Способ второй:
```
lsb_release -a
```

2. Вывести информацию об используемом ядре

Способ - читаем через cat из файла version:
```
cat /proc/version
```

3. Вывести информацию о потребляемых ресурсах в системе

Способ первый - используем встроенную утилиту top
top показывает:
* Кол-во процессов и сами процессы
* Load Average
* Нагрузка на RAM и swap
* Нагрузка на CPU (по умолчанию объединено, словно у нас 1 ядро процессора)

4. Изменить пароль пользователя через терминал

Для текущего пользователя:
```
passwd
```

Для заданного пользователя (выполнить как root):
```
passwd username
```

5. Вывести список всех разделов диска

lsblk (list block devices) позволяет вывести информацию о дисках, флешках и других блочных устройствах
grep позволяет вывести строки, соответствующие заданному паттерну

```
lsblk | grep part
```

6. Показать историю введеных ранее команд

```
history
```

7. Показать список запущенных процессов

ps (processes) позволяет вывести список работающих процессов.
в ps для каждого процесса можно увидеть:
* PID (process ID) - уникальный идентификатор процесса
* TTY (controlling terminal) - терминал, из которого был запущен процесс
* TIME (CPU Time) - время CPU, выделенное процессу на данный момент (не путать с run time)
* CMD (command) - команда, через которую был запущен процесс

ps aux позволяет вывести расширенный список процессов, при этом его можно вводить тремя способами.
	BSD style: ps aux
	UNIX style: ps -aux
	GNU style: ps --quick-pid 10946

a - (all) - lift "only yourself" restriction
u - (user) - show usernames instead of UIDs
x - (executor) - lift "must have a tty" restriction

8. Показать список процессов, которые слушают разные порты в системе

netstat -lntp позволяет вывести список процессов и порты, которые они слушают.

l - (listening) - выводит список процессов, которые слушают порты (без этого флага выводит также те, которые обращаются наружу)
n - (numeric) - выводит численные значения IP адресов
t - (tcp) - выводит TCP соединения
p - (processes) - для каждого соединения показывает процесс (PID and PName), который его установил

9. Вывести системные логи через одну команду

```
sudo journalctl
```

10. Вывести только список папок в домашней директории пользователя

Полный список: du -d 1 ~
Неполный список: ls -d *

11. Посмотреть, сколько места занимают все файлы и папки в домашней директории пользователя, и вывести их по возрастанию

12. Создать скрипт, который выводит "Hello World" и ограничить доступ, не применяя chown, чтобы никто из пользователей системы (кроме root пользователя), не смог выполнить этот скрипт при условии, что он уже исполняемый.
    Вернуть доступ к файлу после выполнения задания.

Выполнить под root пользователем:
```
echo "echo 'Hello World'" > script.sh
chmod g+x,o-x script.sh
chmod g+x,o+x script.sh
```

13. Включить отладку в скрипте

Отладку можно включить с помощью опции -x разными способами

Способ первый - при вызове bash
```bash -x script.sh```

Способ второй - в первой строке bash скрипта
```#!/bin/bash -x```

Способ третий - через оператор set внутри скрипта
```
set -x # Turn on debugging
echo 'Debugging mode is currently on'
set +x # Turn off debugging
echo 'Debugging mode is currently off'
```

При этом dash (-) включает режим, а plus (+) отключает его.

14. Дополнить скрипт проверкой на наличие в системе пакета vim. В случае его отсутствия установить его без вывода подробностей установки. По завершению вывести строку "Completed"

```
#!/bin/bash
if dpkg -s vim &> /dev/null; then
   echo "Vim is installed"
else
   echo "Vim is not installed. Starting the installation..."

   if apt-get install vim -y > /dev/null 2> error_installing_vim.txt; then
      echo "Vim has been successfully installed"
   fi

   if [ -s error_installing_vim.txt ]; then
      echo "An error occurred while installing vim. See it in error_installing_vim.txt"
   else
      rm error_installing_vim.txt
   fi
fi
```

15. Обрезать строку "Hello World" так, чтобы остались только символы "llo Wo" без использования команды cut

```
#!/bin/bash
string="Hello World"
substring=${string:2:6}
echo ${substring}
```

16. Дополнить скрипт, чтобы он давал возможность вводить данные и передавать их скрипту
